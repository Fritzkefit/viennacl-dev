/* =========================================================================
   Copyright (c) 2010-2015, Institute for Microelectronics,
   Institute for Analysis and Scientific Computing,
   TU Wien.
   Portions of this software are copyright by UChicago Argonne, LLC.

   -----------------
   ViennaCL - The Vienna Computing Library
   -----------------

   Project Head:    Karl Rupp                   rupp@iue.tuwien.ac.at

   (A list of authors and contributors can be found in the PDF manual)

   n   License:         MIT (X11), see file LICENSE in the base directory
   ============================================================================= */

/** \file tests/src/libviennacl_blas3.cpp  Testing the BLAS level 3 routines in the ViennaCL BLAS-like shared library
 *   \test Testing the BLAS level 3 routines in the ViennaCL BLAS-like shared library
 **/

#include "viennacl/matrix.hpp"
#include "viennacl/matrix_proxy.hpp"

#include "viennacl/linalg/prod.hpp"

// include necessary system headers
#include <iostream>
#include <vector>

#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/matrix_proxy.hpp>
#include <boost/numeric/ublas/matrix_expression.hpp>

/*
template<typename ScalarType>
ScalarType diff(ScalarType const & s1, ScalarType const & s2)
{
  if (s1 > s2 || s1 < s2)
    return (s1 - s2) / std::max(std::fabs(s1), std::fabs(s2));
  return ScalarType(0);
}

template<typename ScalarType, typename ViennaCLVectorType>
ScalarType diff(std::vector<ScalarType> const & v1, ViennaCLVectorType const & vcl_vec)
{
  std::vector<ScalarType> v2_cpu(vcl_vec.size());
  viennacl::backend::finish();
  viennacl::copy(vcl_vec, v2_cpu);

  ScalarType inf_norm = 0;
  for (unsigned int i=0;i<v1.size(); ++i)
  {
    if ( std::max( std::fabs(v2_cpu[i]), std::fabs(v1[i]) ) > 0 )
      v2_cpu[i] = std::fabs(v2_cpu[i] - v1[i]) / std::max( std::fabs(v2_cpu[i]), std::fabs(v1[i]) );
    else
      v2_cpu[i] = 0.0;

    if (v2_cpu[i] > inf_norm)
      inf_norm = v2_cpu[i];
  }

  return inf_norm;
}

template<typename T, typename U, typename EpsilonT>
void check(T const & t, U const & u, EpsilonT eps)
{
  EpsilonT rel_error = std::fabs(static_cast<EpsilonT>(diff(t,u)));
  if (rel_error > eps)
  {
    std::cerr << "Relative error: " << rel_error << std::endl;
    std::cerr << "Aborting!" << std::endl;
    exit(EXIT_FAILURE);
  }
  std::cout << "SUCCESS ";
}


template<typename T>
T get_value(std::vector<T> & array, ViennaCLInt i, ViennaCLInt j,
            n            ViennaCLInt start1, ViennaCLInt start2,
            ViennaCLInt stride1, ViennaCLInt stride2,
            ViennaCLInt rows, ViennaCLInt cols,
            ViennaCLOrder order, ViennaCLTranspose trans)
{
  // row-major
  if (order == ViennaCLRowMajor && trans == ViennaCLTrans)
    return array[static_cast<std::size_t>((j*stride1 + start1) * cols + (i*stride2 + start2))];
  else if (order == ViennaCLRowMajor && trans != ViennaCLTrans)
    return array[static_cast<std::size_t>((i*stride1 + start1) * cols + (j*stride2 + start2))];

  // column-major
  else if (order != ViennaCLRowMajor && trans == ViennaCLTrans)
    return array[static_cast<std::size_t>((j*stride1 + start1) + (i*stride2 + start2) * rows)];
  return array[static_cast<std::size_t>((i*stride1 + start1) + (j*stride2 + start2) * rows)];
}*/


template<class NumericT, class orderC, class orderA, class orderB>
void test_prod(viennacl::matrix<NumericT,orderC>  & C, viennacl::matrix<NumericT,orderA> & A, viennacl::matrix<NumericT,orderB> & B)
{
  using viennacl::linalg::prod;
  using viennacl::trans;
  
  viennacl::matrix<NumericT,orderA> At = trans(A);
viennacl::matrix<NumericT,orderB> Bt = trans(B);


boost::numeric::ublas::matrix<NumericT, > A_ublas(A.size1(), A.size2());//(A.size1());
  viennacl::copy(A,A_ublas);
  //std::cout << "A: " << A << std::endl;
  //std::cout << "B: " << B << std::endl;

  std::cout << "    -> trans-trans: ";
  C = prod(trans(At),trans(Bt));
 
  std::cout << "       C is:" << C <<std::endl;
  
  std::cout << "    -> trans-no:    ";
  C = prod(trans(At),B);
  std::cout << "       C is:" << C <<std::endl;

  std::cout << "    -> no-trans:    ";
  C = prod(A,trans(Bt));
  std::cout << "       C is:" << C <<std::endl;

  std::cout << "    -> no-no:       ";
  C = prod(A,B);
  std::cout << "       C is:" << C <<std::endl;
}

template<class T, class F>
void init_random(viennacl::matrix<T, F> & M)
{
  std::vector<T> cM(M.internal_size());
  for (std::size_t i = 0; i < M.size1(); ++i)
    for (std::size_t j = 0; j < M.size2(); ++j)
      cM[F::mem_index(i, j, M.internal_size1(), M.internal_size2())] = T(rand())/T(RAND_MAX);
  viennacl::fast_copy(&cM[0],&cM[0] + cM.size(),M);
}

int main(int argc, char **argv)
{
  //float  eps_float  = 1e-5f;
  //double eps_double = 1e-12;

  std::size_t n;
  std::size_t k;
  std::size_t m;

  if(argc == 4)
  {
    m = std::stoi(argv[1]);
    k = std::stoi(argv[2]);
    n = std::stoi(argv[3]);
  }
  else 
  {
    m = 2;
    k = 3;
    n = 2;
  }

  /* float matrices */
  viennacl::matrix<float,viennacl::column_major> Af_col(m,k);
  viennacl::matrix<float,viennacl::column_major> Bf_col(k,n);
  viennacl::matrix<float,viennacl::column_major> Cf_col(m,n);
  init_random(Af_col);
  init_random(Bf_col);
  init_random(Cf_col);
  viennacl::matrix<float,viennacl::row_major> Af_row(m,k);
  viennacl::matrix<float,viennacl::row_major> Bf_row(k,n);
  viennacl::matrix<float,viennacl::row_major> Cf_row(m,n);
  init_random(Af_row);
  init_random(Bf_row);
  init_random(Cf_row);

  /* double matrices */
  viennacl::matrix<double,viennacl::column_major> Ad_col(m,k);
  viennacl::matrix<double,viennacl::column_major> Bd_col(k,n);
  viennacl::matrix<double,viennacl::column_major> Cd_col(m,n);
  init_random(Ad_col);
  init_random(Bd_col);
  init_random(Cd_col);
  viennacl::matrix<double,viennacl::row_major> Ad_row(m,k);
  viennacl::matrix<double,viennacl::row_major> Bd_row(k,n);
  viennacl::matrix<double,viennacl::row_major> Cd_row(m,n);
  init_random(Ad_row);
  init_random(Bd_row);
  init_random(Cd_row);

  std::cout << "*** STARTING TEST ***" << std::endl;
  std::cout << "m = " << m << std::endl;
  std::cout << "k = " << k << std::endl;
  std::cout << "n = " << n << std::endl;
  std::cout << "Af_col is: " << Af_col << std::endl;
  std::cout << "Af_row is: " << Af_row << std::endl;
  std::cout << "Bf_col is: " << Bf_col << std::endl;
  std::cout << "Bf_row is: " << Bf_row << std::endl;
  std::cout << "*********************" << std::endl << std::endl;
  
  std::cout << "  -> C: row, A: row, B: row" << std::endl;
  test_prod(Cf_row, Af_row, Bf_row);
  //test_prod(Cd_row, Ad_row, Bd_row);

  std::cout << "  -> C: row, A: row, B: col" << std::endl;
  test_prod(Cf_row, Af_row, Bf_col);
  //test_prod(Cd_row, Ad_row, Bd_col);

  std::cout << "  -> C: row, A: col, B: row" << std::endl;
  test_prod(Cf_row, Af_col, Bf_row);
  //test_prod(Cd_row, Ad_col, Bd_row);

  std::cout << "  -> C: row, A: col, B: col" << std::endl;
  test_prod(Cf_row, Af_col, Bf_col);
  //test_prod(Cd_row, Ad_col, Bd_col);

  std::cout << "  -> C: col, A: row, B: row" << std::endl;
  test_prod(Cf_col, Af_row, Bf_row);
  //test_prod(Cd_col, Ad_row, Bd_row);

  std::cout << "  -> C: col, A: row, B: col" << std::endl;
  test_prod(Cf_col, Af_row, Bf_col);
  //test_prod(Cd_col, Ad_row, Bd_col);

  std::cout << "  -> C: col, A: col, B: row" << std::endl;
  test_prod(Cf_col, Af_col, Bf_row);
  //test_prod(Cd_col, Ad_col, Bd_row);

  std::cout << "  -> C: col, A: col, B: col" << std::endl;
  test_prod(Cf_col, Af_col, Bf_col);
  //test_prod(Cd_col, Ad_col, Bd_col);

  //
  //  That's it.
  //
  std::cout << std::endl << "!!!! TEST COMPLETED SUCCESSFULLY !!!!" << std::endl;

  return EXIT_SUCCESS;
}

