#include "viennacl/forwards.h"
#include "viennacl/matrix.hpp"
#include "viennacl/matrix_proxy.hpp"

#include <stdlib.h>

template<typename T>
T get_value(std::vector<T> & array, ViennaCLInt i, ViennaCLInt j,
              ViennaCLInt start1, ViennaCLInt start2,
            ViennaCLInt stride1, ViennaCLInt stride2,
            ViennaCLInt rows, ViennaCLInt cols,
            ViennaCLOrder order, ViennaCLTranspose trans)
{
  // row-major
  if (order == ViennaCLRowMajor && trans == ViennaCLTrans)
    return array[static_cast<std::size_t>((j*stride1 + start1) * cols + (i*stride2 + start2))];
  else if (order == ViennaCLRowMajor && trans != ViennaCLTrans)
    return array[static_cast<std::size_t>((i*stride1 + start1) * cols + (j*stride2 + start2))];

  // column-major
  else if (order != ViennaCLRowMajor && trans == ViennaCLTrans)
    return array[static_cast<std::size_t>((j*stride1 + start1) + (i*stride2 + start2) * rows)];
  return array[static_cast<std::size_t>((i*stride1 + start1) + (j*stride2 + start2) * rows)];
}

template<class T, class F>
void init_random(viennacl::matrix<T, F> & M)
{
  std::vector<T> cM(M.internal_size());
  for (std::size_t i = 0; i < M.size1(); ++i)
    for (std::size_t j = 0; j < M.size2(); ++j)
      cM[F::mem_index(i, j, M.internal_size1(), M.internal_size2())] = T(rand())/T(RAND_MAX);
  viennacl::fast_copy(&cM[0],&cM[0] + cM.size(),M);
}

int main()
{
  viennacl::matrix<double,viennacl::row_major> a(2,3);
  viennacl::matrix<double,viennacl::column_major> at = trans(a);

  std::cout << "a sizes " << a.size1() << " "
            << a.size2() << " " << a.internal_size1() << " " << a.internal_size2() << std::endl;

  std::cout << "at sizes " << a.size1() << " " << a.size2() 
            << a.internal_size1() << " " << a.internal_size2() << std::endl;

  std::cout << "a is " << a << std::endl;
  std::cout << "at is " << at << std::endl;

  using viennacl::linalg::host_based::prod;
  
  viennacl::tools::uniform_random_numbers<float>  randomFloat;
  viennacl::tools::uniform_random_numbers<double> randomDouble;



  /*  float C_float[C_size1*C_size2];
  float A_float[A_size1*A_size2];
  float B_float[B_size1*B_size2];

  double C_double[C_size1*C_size2];
  double A_double[A_size1*A_size2];
  double B_double[B_size1*B_size2];

  // fill with random data:  
  for (std::size_t i = 0; i < C_size1*C_size2; ++i)
  {
    C_float[i] = 0.5f + 0.1f * randomFloat();
    C_double[i] = 0.5 + 0.2 * randomDouble();
  }
  for (std::size_t i = 0; i < A_size1*A_size2; ++i)
  {
    A_float[i] = 0.5f + 0.1f * randomFloat();
    A_double[i] = 0.5 + 0.2 * randomDouble();
  }
  for (std::size_t i = 0; i < B_size1*B_size2; ++i)
  {
    B_float[i] = 0.5f + 0.1f * randomFloat();
    B_double[i] = 0.5 + 0.2 * randomDouble();
  }


  for (ViennaCLInt i=0; i<C_size1; ++i)
    for (ViennaCLInt j=0; j<C_size2; ++j)
    {
      float val_float = 0;
      double val_double = 0;
      for (ViennaCLInt k=0; k<size_k; ++k)
      {
        float  val_A_float  = get_value(A_float,  i, k, A_start1, A_start2, A_stride1, A_stride2, A_rows, A_columns, order_A, trans_A);
        double val_A_double = get_value(A_double, i, k, A_start1, A_start2, A_stride1, A_stride2, A_rows, A_columns, order_A, trans_A);

        float  val_B_float  = get_value(B_float,  k, j, B_start1, B_start2, B_stride1, B_stride2, B_rows, B_columns, order_B, trans_B);
        double val_B_double = get_value(B_double, k, j, B_start1, B_start2, B_stride1, B_stride2, B_rows, B_columns, order_B, trans_B);

        val_float  += val_A_float  * val_B_float;
        val_double += val_A_double * val_B_double;
      }

      // write result
      if (order_C == ViennaCLRowMajor)
      {
        C_float [static_cast<std::size_t>((i*C_stride1 + C_start1) * C_columns + (j*C_stride2 + C_start2))] = val_float;
        C_double[static_cast<std::size_t>((i*C_stride1 + C_start1) * C_columns + (j*C_stride2 + C_start2))] = val_double;
      }
      else
      {
        C_float [static_cast<std::size_t>((i*C_stride1 + C_start1) + (j*C_stride2 + C_start2) * C_rows)] = val_float;
        C_double[static_cast<std::size_t>((i*C_stride1 + C_start1) + (j*C_stride2 + C_start2) * C_rows)] = val_double;
      }
    }




  // FOR NOW WITHOUT BETA+ALPHA!!
  for (vcl_size_t i=0; i<size_m; ++i)
  {
    for (vcl_size_t j=0; j<size_k; ++j)
    {
      for(vcl_size_t k=0; k<size_n; ++k)
      {
        
        return 0;
      }    
    }
  }*/
}
